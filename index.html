<!doctype html>
<html>

<head>
  <meta charset="utf-8" />
  <title>FRC Fuel Sim (Phaser + Matter) — Robots as Class + Hubs as Class</title>
  <style>
    body {
      margin: 0;
      background: #111;
      height: 100vh;
    }

    #layout {
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    /* Make container the positioning context for overlay UI */
    #gameContainer {
      position: relative;
      display: inline-block;
      /* shrink-wrap to canvas */
    }

    /* keep your canvas styling */
    #gameContainer canvas {
      border: 1px solid #333;
      max-width: 98vw;
      max-height: 80vh;
      display: block;
      /* remove baseline gap */
    }

    /* Overlay UI */
    /* --- override: vertically center the overlay UI --- */
    #controlBar {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;

      height: 100px;
      /* adjust 40–52 if you want */
      display: grid;
      grid-template-columns: 1fr 1fr;
      align-items: center;
      /* centers halves vertically */
      padding: 0 12px;
      /* no vertical padding */
      background: transparent;
      border: none;
      border-radius: 0;
      box-shadow: none;
      backdrop-filter: none;

      color: #ddd;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      pointer-events: auto;
    }

    .leftHalf,
    .rightHalf {
      display: flex;
      align-items: center;
      /* centers items vertically */
      justify-content: center;
      /* centers within each half (zone) */
      gap: 10px;
      height: 100%;
    }

    /* Helps text/select baselines not sag */
    #controlBar label,
    #controlBar select,
    .team,
    .hint {
      line-height: 1;
    }

    .team {
      font-weight: 700;
      padding: 2px 8px;
      border-radius: 8px;
      border: 1px solid #333;
    }

    .team.red {
      color: #ff8a8a;
    }

    .team.blue {
      color: #7cc7ff;
    }

    #controlBar label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      opacity: 0.95;
    }

    #controlBar select {
      background: #222;
      color: #ddd;
      border: 1px solid #444;
      padding: 4px 8px;
      border-radius: 8px;
    }

    .hint {
      font-size: 12px;
      opacity: 0.75;
      white-space: nowrap;
    }
  </style>
</head>

<body>
  <div id="layout">
    <div id="gameContainer">
      <div id="controlBar">
        <div class="ctrlRow leftHalf">
          <span class="team red">Red</span>
          <label>
            Controller
            <select id="redControllerSelect">
              <option value="human">Gamepad/KB</option>
              <option value="cursor">Cursor</option>
              <option value="fuelSeeker">Auto Fuel Seeker</option>
              <option value="adaptiveHub">Auto Adaptive Hub</option>
            </select>
          </label>
          <span id="redKbHint" class="hint"></span>
        </div>

        <div class="ctrlRow rightHalf">
          <span class="team blue">Blue</span>
          <label>
            Controller
            <select id="blueControllerSelect">
              <option value="human">Gamepad/KB</option>
              <option value="cursor">Cursor</option>
              <option value="fuelSeeker">Auto Fuel Seeker</option>
              <option value="adaptiveHub">Auto Adaptive Hub</option>
            </select>
          </label>
          <span id="blueKbHint" class="hint"></span>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.js"></script>
  <script>
    // -----------------------------
    // SCALE + FIELD
    // -----------------------------
    const PX_PER_FT = 24;
    const FIELD_W = 54 * PX_PER_FT; // 1296
    const FIELD_H = 27 * PX_PER_FT; // 648

    // UI strips (rendered inside Phaser, camera scrolled)
    const UI_H = 130;
    const GAME_H = FIELD_H + UI_H;

    // Reference lines (zone boundaries)
    const RED_LINE_X = 15 * PX_PER_FT;              // left line
    const BLUE_LINE_X = FIELD_W - (15 * PX_PER_FT); // right line

    // -----------------------------
    // ROBOTS (30" per side)
    // -----------------------------
    const ROBOT_W = (30 / 12) * PX_PER_FT; // 60
    const ROBOT_H = (30 / 12) * PX_PER_FT; // 60
    const ROBOT_SPEED = 6.0;
    const ROBOT_SPIN_SPEED = 0.06;

    // Convention: forward = body.angle + FORWARD_OFFSET
    const FORWARD_OFFSET = -Math.PI / 2;

    // Preload
    const PRELOADED_FUEL = 8;

    // -----------------------------
    // TURRET
    // -----------------------------
    const TURRET_LEN = 22;
    const TURRET_WIDTH = 8;
    const TURRET_YAW_OFFSET = 0;
    const TURRET_MAX_OMEGA = 3.0;

    // -----------------------------
    // HUBS (solid) + HEX SENSORS
    // -----------------------------
    const HUB_W = 4 * PX_PER_FT; // 96
    const HUB_H = 4 * PX_PER_FT;
    const HUB_HEX_GAP_PX = 3; // inset gap
    const HUB_GLOW_ALPHA = 0.50;  // active glow fill alpha
    const HUB_GLOW_ALPHA_INACTIVE = 0.06; // faint even when inactive (optional)

    const HUB_EJECT_DELAY_MS = 1000;

    // Spawn point just inside neutral, next to the hub
    const HUB_EJECT_OFFSET_X = (HUB_W / 2) + 10;
    const HUB_EJECT_JITTER_Y = 18;

    // Ejection velocity
    const HUB_EJECT_SPEED_MIN = 6;
    const HUB_EJECT_SPEED_MAX = 12;

    // Angle spread around “into neutral”
    const HUB_EJECT_SPREAD = Math.PI / 2; // +/- 45°


    // -----------------------------
    // FUEL GRID
    // -----------------------------
    const GRID_COLS = 12;
    const GRID_ROWS = 30;

    const FUEL_R = 6;
    const FUEL_SPACING_X = 13;
    const FUEL_SPACING_Y = 13;
    const GRID_JITTER = 0.0;

    // 2" horizontal gap between top/bottom halves
    const GRID_MID_GAP_PX = (2 / 12) * PX_PER_FT; // 4 px

    // -----------------------------
    // FUEL DEPOTS (per alliance zone)
    // -----------------------------
    const DEPOT_COLS = 4;
    const DEPOT_ROWS = 6;

    // Inset from field walls so fuel isn't spawned inside the boundary thickness
    const DEPOT_INSET_X = 8;
    const DEPOT_INSET_Y = 8;


    // Fuel physics
    const FUEL_RESTITUTION = 0.25;
    const FUEL_FRICTION = 0.02;
    const FUEL_FRICTION_AIR = 0.03;
    const FUEL_DENSITY = 0.001;
    const FUEL_SLEEP_THRESHOLD = 60;

    // Fuel colors
    const FUEL_COLOR_GROUND = 0xffb000;
    const FUEL_COLOR_SHOT = 0xffdd55;

    // -----------------------------
    // INTAKES
    // -----------------------------
    const INTAKE_W = (24 / 12) * PX_PER_FT;  // 48
    const INTAKE_H = (10 / 12) * PX_PER_FT;  // 20
    const INTAKE_OFFSET = (ROBOT_W / 2) + (INTAKE_H / 2) + 2;
    const INTAKE_ANGLE_OFFSET = Math.PI / 2;

    const MAX_STORAGE = 25;
    const INTAKE_GRAB_RADIUS = 12;
    const INTAKE_GRAB_PER_TICK = 1;

    // -----------------------------
    // SHOOTING + AIRBORNE (Option A)
    // -----------------------------
    const SHOT_PAUSE_MS = 120;
    const SHOOT_SPEED = 14;
    const SHOOT_SPREAD = 0.12;

    const SHOT_FLIGHT_MS = 700;

    // -----------------------------
    // MATCH / TIMEFRAMES
    // -----------------------------
    const TIMEFRAMES = [
      {name: "AUTO", durationS: 20},
      {name: "TRANSITION", durationS: 10},
      {name: "SHIFT1", durationS: 25},
      {name: "SHIFT2", durationS: 25},
      {name: "SHIFT3", durationS: 25},
      {name: "SHIFT4", durationS: 25},
      {name: "ENDGAME", durationS: 30},
    ];
    const TIMEFRAME_DISPLAY_LABELS = Object.freeze({
      AUTO: "AUTO",
      TRANSITION: "1/6",
      SHIFT1: "2/6",
      SHIFT2: "3/6",
      SHIFT3: "4/6",
      SHIFT4: "5/6",
      ENDGAME: "6/6",
    });
    const MATCH_TIME_S = TIMEFRAMES.reduce((a, t) => a + t.durationS, 0); // 150

    // -----------------------------
    // ZONES (first-class)
    // -----------------------------
    const ZoneId = Object.freeze({
      RED: "RED",
      NEUTRAL: "NEUTRAL",
      BLUE: "BLUE",
    });

    class Zone {
      constructor(id, x0, x1) {
        this.id = id;
        this.x0 = x0;
        this.x1 = x1;
      }
      containsX(x) {return x >= this.x0 && x < this.x1;}
      centerX() {return (this.x0 + this.x1) / 2;}
    }

    // -----------------------------
    // HUB CLASS
    // -----------------------------
    class Hub {
      constructor(scene, {name, cx, cy, colorFill, colorLine, sensorTagName}) {
        this.scene = scene;
        this.name = name;
        this.center = {x: cx, y: cy};
        this.active = true;
        this.fuelStore = []; // array of { fuel: Fuel, capturedAtMs: number }


        // Solid hub body (square obstacle)
        this.body = scene.matter.add.rectangle(cx, cy, HUB_W, HUB_H, {isStatic: true, isSensor: false});
        this.body.collisionFilter.category = scene.CAT_HUBS;
        this.body.collisionFilter.mask = scene.CAT_FUEL | scene.CAT_ROBOT;

        // Sensor (hex) for scoring
        this.sensor = scene.addHexSensor(cx, cy, scene.hubHexR, scene.CAT_SENSOR, scene.CAT_FUEL, sensorTagName);

        // Visuals
        this.gfx = scene.add.graphics().setDepth(3);
        this.hexOutlineG = scene.add.graphics().setDepth(4);

        this.colorFill = colorFill;
        this.colorLine = colorLine;
        this.flashWarning = false;
        this.flashOn = false;

        this.draw();
      }

      setActive(isActive) {
        this.active = !!isActive;
        this.draw();
      }

      setFlashWarning(isWarning, nowMs) {
        const wantWarning = !!isWarning;
        if (!wantWarning) {
          if (this.flashWarning || this.flashOn) {
            this.flashWarning = false;
            this.flashOn = false;
            this.draw();
          }
          return;
        }

        const blinkOn = (Math.floor(nowMs / 180) % 2) === 0;
        if (!this.flashWarning || this.flashOn !== blinkOn) {
          this.flashWarning = true;
          this.flashOn = blinkOn;
          this.draw();
        }
      }

      draw() {
        const {x, y} = this.center;
        const r = this.scene.hubHexR;

        this.gfx.clear();
        this.hexOutlineG.clear();

        // Solid 4'x4' hub square
        const isBlue = (this.name === "Blue");
        const squareFill = isBlue ? 0x0b2a5b : 0x5b0b0b;
        const squareStroke = this.colorLine;

        this.gfx.fillStyle(squareFill, 1);
        this.gfx.fillRect(x - HUB_W / 2, y - HUB_H / 2, HUB_W, HUB_H);

        this.gfx.lineStyle(3, squareStroke, 1);
        this.gfx.strokeRect(x - HUB_W / 2, y - HUB_H / 2, HUB_W, HUB_H);

        // Hex glow fill
        let alpha = this.active ? HUB_GLOW_ALPHA : HUB_GLOW_ALPHA_INACTIVE;
        let glowColor = FUEL_COLOR_SHOT;
        if (this.flashWarning && this.flashOn) {
          alpha = 0.92;
          glowColor = 0xffffff;
        }

        const pts = [];
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 3) * i;
          pts.push(new Phaser.Math.Vector2(x + Math.cos(a) * r, y + Math.sin(a) * r));
        }

        if (alpha > 0) {
          this.gfx.fillStyle(glowColor, alpha);
          this.gfx.beginPath();
          this.gfx.moveTo(pts[0].x, pts[0].y);
          for (let i = 1; i < pts.length; i++) this.gfx.lineTo(pts[i].x, pts[i].y);
          this.gfx.closePath();
          this.gfx.fillPath();
        }

        // Hex outline always
        if (this.flashWarning && this.flashOn) {
          this.hexOutlineG.lineStyle(4, 0xffffff, 1);
        } else {
          this.hexOutlineG.lineStyle(2, this.colorLine, 1);
        }
        for (let i = 0; i < 6; i++) {
          const p0 = pts[i];
          const p1 = pts[(i + 1) % 6];
          this.hexOutlineG.lineBetween(p0.x, p0.y, p1.x, p1.y);
        }
      }

      captureFuel(fuelObj, nowMs) {
        fuelObj.stash(`Hub:${this.name}`);
        this.fuelStore.push({fuel: fuelObj, capturedAtMs: nowMs});
      }

      // Called every frame to eject fuel that has been captured for >= HUB_EJECT_DELAY_MS
      update(nowMs) {
        // Eject any fuel that has been captured >= delay
        while (this.fuelStore.length > 0) {
          const item = this.fuelStore[0];
          if ((nowMs - item.capturedAtMs) < HUB_EJECT_DELAY_MS) break;

          this.fuelStore.shift();
          this.ejectFuelIntoNeutral(item.fuel);
        }
      }

      // helper: eject fuel into neutral zone
      ejectFuelIntoNeutral(fuelObj) {
        const scene = this.scene;

        // Determine which direction is "into neutral"
        // Red hub is on RED_LINE_X, neutral is to the right (+x)
        // Blue hub is on BLUE_LINE_X, neutral is to the left (-x)
        const isRed = (this.name === "Red");
        const baseAng = isRed ? 0 : Math.PI;

        // Spawn position: just inside neutral zone next to this hub
        let x = isRed
          ? (this.center.x + HUB_EJECT_OFFSET_X)
          : (this.center.x - HUB_EJECT_OFFSET_X);

        let y = this.center.y + Phaser.Math.FloatBetween(-HUB_EJECT_JITTER_Y, HUB_EJECT_JITTER_Y);

        // Clamp into field bounds (avoid walls)
        x = Phaser.Math.Clamp(x, 20, FIELD_W - 20);
        y = Phaser.Math.Clamp(y, 20, FIELD_H - 20);

        // Re-spawn as WORLD ground fuel (visible + physics body)
        fuelObj.spawnGround(x, y);

        // Give it a random kick into neutral
        const ang = baseAng + Phaser.Math.FloatBetween(-HUB_EJECT_SPREAD / 2, HUB_EJECT_SPREAD / 2);
        const speed = Phaser.Math.FloatBetween(HUB_EJECT_SPEED_MIN, HUB_EJECT_SPEED_MAX);

        scene.matter.body.setVelocity(fuelObj.body, {
          x: Math.cos(ang) * speed,
          y: Math.sin(ang) * speed
        });
      }

    }

    // -----------------------------
    // ROBOT CLASS
    // -----------------------------
    class Robot {
      constructor(scene, {name, x, y, color, preloadedFuel, controls}) {
        this.scene = scene;
        this.name = name;
        this.controls = controls;
        this.controller = new HumanController();

        this.state = new scene.RobotState(); // stores array, not a counter

        // Matter bodies (compound: chassis + intake sensor part)
        const Bodies = Phaser.Physics.Matter.Matter.Bodies;
        const Body = Phaser.Physics.Matter.Matter.Body;

        const chassis = Bodies.rectangle(x, y, ROBOT_W, ROBOT_H, {
          chamfer: {radius: 10}
        });

        // Intake sensor rectangle located in front of robot.
        // NOTE: This position is initial; it will move with the compound body.
        const intakeOffsetX = (ROBOT_W / 2) + (INTAKE_W / 2) - 2; // tweak the -2 to taste
        const intakeOffsetY = 0;

        const intake = Bodies.rectangle(x + intakeOffsetX, y + intakeOffsetY, INTAKE_W, INTAKE_H, {
          isSensor: true
        });

        // Tag the intake part so the collision handler can recognize it
        intake.isIntakeSensor = true;
        intake.robotName = this.name;

        // Build the compound body
        const compound = Body.create({
          parts: [chassis, intake],
          friction: 0.05,
          frictionAir: 0.12,
          restitution: 0.05,
          density: 0.01,
          sleepThreshold: 0
        });

        // Add to world
        this.body = scene.matter.add.gameObject(scene.add.rectangle(0, 0, 1, 1, 0x000000, 0), compound).body;
        // ^ creates a dummy GameObject for Matter; your real visuals are your Graphics, so this stays invisible.

        // Collision filtering (apply to the compound root; parts inherit behavior in practice)
        this.body.collisionFilter.category = scene.CAT_ROBOT;
        this.body.collisionFilter.mask = scene.CAT_FUEL | scene.CAT_FIELD_WALLS | scene.CAT_HUBS | scene.CAT_ROBOT;

        // Keep a handle to the intake part for drawing (optional but convenient)
        this.intakeBody = intake;


        // Visuals
        this.gfx = scene.add.graphics().setDepth(10);
        this.gfx.fillStyle(color, 1);
        this.gfx.fillRoundedRect(-ROBOT_W / 2, -ROBOT_H / 2, ROBOT_W, ROBOT_H, 10);

        this.intakeG = scene.add.graphics().setDepth(11);

        this.label = scene.add.text(0, 0, "", {
          fontFamily: "monospace",
          fontSize: "18px",
          fontStyle: "bold",
          color: "#000000",
          stroke: "#ffffff",
          strokeThickness: 4,
        }).setOrigin(0.5, 0.5).setDepth(30);

        this.turretG = scene.add.graphics().setDepth(20);
        this.turretG.lineStyle(TURRET_WIDTH, 0xdddddd, 1);
        this.turretG.lineBetween(0, 0, TURRET_LEN, 0);

        this.turretAngle = this.body.angle + FORWARD_OFFSET;
      }

      setPose({x, y, angle}) {
        const s = this.scene;
        s.matter.body.setPosition(this.body, {x, y});
        s.matter.body.setVelocity(this.body, {x: 0, y: 0});
        s.matter.body.setAngle(this.body, angle);
        s.matter.body.setAngularVelocity(this.body, 0);

        const forwardAng = angle + FORWARD_OFFSET;
        const ix = x + Math.cos(forwardAng) * INTAKE_OFFSET;
        const iy = y + Math.sin(forwardAng) * INTAKE_OFFSET;

        s.matter.body.setPosition(this.intakeBody, {x: ix, y: iy});
        s.matter.body.setVelocity(this.intakeBody, {x: 0, y: 0});
        s.matter.body.setAngle(this.intakeBody, forwardAng + INTAKE_ANGLE_OFFSET);

        // Keep visuals in sync even while the match is paused (initial load/reset).
        this.gfx.x = x;
        this.gfx.y = y;
        this.gfx.rotation = angle;

        this.intakeG.x = ix;
        this.intakeG.y = iy;
        this.intakeG.rotation = forwardAng + INTAKE_ANGLE_OFFSET;
        this.intakeG.clear();
        this.intakeG.lineStyle(2, 0xff4444, 1);
        const w = INTAKE_W, h = INTAKE_H;
        this.intakeG.lineBetween(-w / 2, -h / 2, -w / 2, h / 2);
        this.intakeG.lineBetween(w / 2, -h / 2, w / 2, h / 2);
        this.intakeG.lineBetween(-w / 2, h / 2, w / 2, h / 2);

        this.turretAngle = forwardAng;
        this.turretG.x = x;
        this.turretG.y = y;
        this.turretG.rotation = this.turretAngle;

        this.label.setText(`${this.state?.fuelStore?.length ?? 0}`);
        this.label.x = x;
        this.label.y = y;
        this.label.rotation = 0;
      }

      update(delta) {
        const scene = this.scene;

        // Controller -> commands (Patch 1)
        const cmd = this.controller.getCommands(scene, this, delta);

        // Apply drive
        scene.matter.body.setVelocity(this.body, {x: cmd.vx, y: cmd.vy});

        // Apply spin
        scene.matter.body.setAngularVelocity(this.body, cmd.omega);

        // Apply shoot
        if (!scene.matchOver && cmd.shoot) {
          scene.tryShoot(this);
        }


        // Attach intake in front
        const forwardAng = this.body.angle + FORWARD_OFFSET;
        const ix = this.body.position.x + Math.cos(forwardAng) * INTAKE_OFFSET;
        const iy = this.body.position.y + Math.sin(forwardAng) * INTAKE_OFFSET;

        scene.matter.body.setPosition(this.intakeBody, {x: ix, y: iy});
        scene.matter.body.setAngle(this.intakeBody, forwardAng + INTAKE_ANGLE_OFFSET);
        scene.matter.body.setVelocity(this.intakeBody, {x: this.body.velocity.x, y: this.body.velocity.y});

        // Sync visuals
        this.gfx.x = this.body.position.x;
        this.gfx.y = this.body.position.y;
        this.gfx.rotation = this.body.angle;

        this.intakeG.x = this.intakeBody.position.x;
        this.intakeG.y = this.intakeBody.position.y;
        this.intakeG.rotation = this.intakeBody.angle;
        this.intakeG.clear();
        this.intakeG.lineStyle(2, 0xff4444, 1);
        const w = INTAKE_W, h = INTAKE_H;
        this.intakeG.lineBetween(-w / 2, -h / 2, -w / 2, h / 2);
        this.intakeG.lineBetween(w / 2, -h / 2, w / 2, h / 2);
        this.intakeG.lineBetween(-w / 2, h / 2, w / 2, h / 2);

        // Turret aim:
        // - If robot is in NEUTRAL zone: aim at nearer of (top-center, bottom-center) of the robot's OWN zone
        // - Otherwise: aim at corresponding hub center
        const rx = this.body.position.x;
        const ry = this.body.position.y;

        let tx, ty;

        const myZoneId = scene.getZoneForX(rx).id;
        const allianceZoneId = (this.name === "Blue") ? ZoneId.BLUE : ZoneId.RED;

        if (myZoneId !== allianceZoneId) {
          const z = scene.zones.find(zz => zz.id === allianceZoneId);

          const zx = z.centerX();
          const top = {x: zx, y: FIELD_H * 0.25};
          const bot = {x: zx, y: FIELD_H * 0.75};

          const dTop = (top.x - rx) * (top.x - rx) + (top.y - ry) * (top.y - ry);
          const dBot = (bot.x - rx) * (bot.x - rx) + (bot.y - ry) * (bot.y - ry);

          const pick = (dTop <= dBot) ? top : bot;
          tx = pick.x;
          ty = pick.y;
        } else {
          const hub = (this.name === "Blue") ? scene.blueHub.center : scene.redHub.center;
          tx = hub.x;
          ty = hub.y;
        }

        const target = Math.atan2(ty - ry, tx - rx) + TURRET_YAW_OFFSET;

        const dt = Math.max(0.001, (delta || 16.7) / 1000.0);
        const maxStep = TURRET_MAX_OMEGA * dt;

        let err = Phaser.Math.Angle.Wrap(target - this.turretAngle);
        err = Phaser.Math.Clamp(err, -maxStep, maxStep);
        this.turretAngle = Phaser.Math.Angle.Wrap(this.turretAngle + err);

        this.turretG.x = rx;
        this.turretG.y = ry;
        this.turretG.rotation = this.turretAngle;

        // Fuel count label (upright) — array length
        this.label.setText(`${this.state.fuelStore.length}`);
        this.label.x = rx;
        this.label.y = ry;
        this.label.rotation = 0;
      }

      setController(controller) {
        this.controller = controller || new HumanController();
      }
    }

    // -----------------------------
    // FUEL CLASS
    // scene.fuels contains ALL Fuel objects:
    // - world fuel: has body/gfx
    // - stored fuel: body/gfx are null, isStored=true, owner set
    // -----------------------------
    class Fuel {
      constructor(scene) {
        this.scene = scene;
        this.body = null;
        this.gfx = null;
        this.glowG = null;

        this.owner = null;     // "Red" | "Blue" | null
        this.isStored = false; // inside robot
      }

      spawnGround(x, y) {
        const fuel = this.scene.matter.add.circle(x, y, FUEL_R, {
          restitution: FUEL_RESTITUTION,
          friction: FUEL_FRICTION,
          frictionAir: FUEL_FRICTION_AIR,
          density: FUEL_DENSITY,
          sleepThreshold: FUEL_SLEEP_THRESHOLD
        });

        fuel.collisionFilter.category = this.scene.CAT_FUEL;
        fuel.collisionFilter.mask =
          this.scene.CAT_FUEL | this.scene.CAT_ROBOT | this.scene.CAT_FIELD_WALLS | this.scene.CAT_HUBS | this.scene.CAT_SENSOR;

        fuel.isFuel = true;
        fuel.wasShot = false;
        fuel.isAirborne = false;

        const fuelG = this.scene.add.graphics().setDepth(5);
        fuelG.fillStyle(FUEL_COLOR_GROUND, 1);
        fuelG.fillCircle(0, 0, FUEL_R);
        fuelG.x = fuel.position.x;
        fuelG.y = fuel.position.y;

        this.body = fuel;
        this.body.fuelRef = this;
        this.gfx = fuelG;
        this.glowG = null;

        this.owner = null;
        this.isStored = false;

        fuel.fuelObj = this;
        return this;
      }

      spawnFromShot({sx, sy, ang, now, CAT_FUEL, CAT_FIELD_WALLS, CAT_SENSOR}) {
        const scene = this.scene;

        const shot = scene.matter.add.circle(sx, sy, FUEL_R, {
          restitution: 0.15,
          friction: 0.01,
          frictionAir: 0.01,
          density: FUEL_DENSITY,
          sleepThreshold: 0
        });

        shot.collisionFilter.category = CAT_FUEL;

        // AIRBORNE: collide with outer walls + sensors only
        shot.collisionFilter.mask = CAT_FIELD_WALLS | CAT_SENSOR;

        shot.isFuel = true;
        shot.wasShot = true;
        shot.isAirborne = true;
        shot.landAtMs = now + SHOT_FLIGHT_MS;

        scene.matter.body.setVelocity(shot, {
          x: Math.cos(ang) * SHOOT_SPEED,
          y: Math.sin(ang) * SHOOT_SPEED
        });

        const fuelG = scene.add.graphics().setDepth(5);
        fuelG.fillStyle(FUEL_COLOR_SHOT, 1);
        fuelG.fillCircle(0, 0, FUEL_R);
        fuelG.x = shot.position.x;
        fuelG.y = shot.position.y;

        this.body = shot;
        this.body.fuelRef = this;
        this.gfx = fuelG;
        this.glowG = null;

        this.owner = null;
        this.isStored = false;

        shot.fuelObj = this;

        return this;
      }

      stash(ownerName) {
        this.owner = ownerName || null;
        this.isStored = true;

        if (this.gfx) this.gfx.destroy();
        if (this.glowG) this.glowG.destroy();
        if (this.body) this.scene.matter.world.remove(this.body);

        this.body = null;
        this.gfx = null;
        this.glowG = null;
      }

      update(now) {
        const b = this.body;
        if (!b) return; // stored fuel has no body

        if (b.isAirborne && now >= b.landAtMs) {
          b.isAirborne = false;
          b.wasShot = false; // cannot score after landing

          b.collisionFilter.mask =
            this.scene.CAT_FUEL |
            this.scene.CAT_ROBOT |
            this.scene.CAT_FIELD_WALLS |
            this.scene.CAT_HUBS |
            this.scene.CAT_SENSOR;

          this.gfx.clear();
          this.gfx.fillStyle(FUEL_COLOR_GROUND, 1);
          this.gfx.fillCircle(0, 0, FUEL_R);

          if (this.glowG) this.glowG.clear();
        }

        if (b.isAirborne) {
          this.gfx.setAlpha(1.0);
          this.gfx.setScale(1.15);

          if (!this.glowG) this.glowG = this.scene.add.graphics().setDepth(6);
          this.glowG.clear();
          this.glowG.lineStyle(1, 0xffffff, 0.7);
          this.glowG.strokeCircle(b.position.x, b.position.y, FUEL_R * 1.6);
          this.glowG.lineStyle(2, 0xffdd55, 0.8);
          this.glowG.strokeCircle(b.position.x, b.position.y, FUEL_R * 1.25);
        } else {
          this.gfx.setAlpha(1.0);
          this.gfx.setScale(1.0);
          if (this.glowG) this.glowG.clear();
        }

        this.gfx.x = b.position.x;
        this.gfx.y = b.position.y;
      }

      destroy() {
        if (this.gfx) this.gfx.destroy();
        if (this.glowG) this.glowG.destroy();
        if (this.body) this.scene.matter.world.remove(this.body);

        this.body = null;
        this.gfx = null;
        this.glowG = null;
      }
    }


    class BaseController {
      /**
       * Return desired commands for this frame.
       * @returns {{ vx:number, vy:number, omega:number, shoot:boolean }}
       */
      getCommands(scene, robot, delta) {
        return {vx: 0, vy: 0, omega: 0, shoot: false};
      }
    }

    // -----------------------------
    // HUMAN CONTROLLER (merges keyboard + gamepad)
    // -----------------------------
    class HumanController extends BaseController {
      getCommands(scene, robot, delta) {
        if (scene.matchOver) {
          return {vx: 0, vy: 0, omega: 0, shoot: false};
        }

        // ---------- Keyboard digital (existing behavior) ----------
        let kx = 0, ky = 0, kOmega = 0;

        if (robot.controls.left.isDown) kx -= 1;
        if (robot.controls.right.isDown) kx += 1;
        if (robot.controls.up.isDown) ky -= 1;
        if (robot.controls.down.isDown) ky += 1;

        // normalize diagonal for keyboard
        if (kx !== 0 && ky !== 0) {
          const inv = 1 / Math.sqrt(2);
          kx *= inv; ky *= inv;
        }

        if (robot.controls.spinL.isDown) kOmega -= 1;
        if (robot.controls.spinR.isDown) kOmega += 1;

        const kShoot = robot.controls.shootKey.isDown;

        // Scale to your sim’s units
        let vx = kx * ROBOT_SPEED;
        let vy = ky * ROBOT_SPEED;
        let omega = kOmega * ROBOT_SPIN_SPEED;
        let shoot = kShoot;

        // ---------- Gamepad (overrides drive if stick moved) ----------
        const pad = scene.getGamepadForRobot(robot);
        if (pad && pad.connected) {
          const DEADZONE = 0.18;

          // Left stick for drive (Phaser: axes[0]=LX, axes[1]=LY)
          const ax = pad.axes.length > 0 ? pad.axes[0].getValue() : 0;
          const ay = pad.axes.length > 1 ? pad.axes[1].getValue() : 0;

          // D-pad as digital drive (optional, nice fallback)
          const dpx = (pad.left ? -1 : 0) + (pad.right ? 1 : 0);
          const dpy = (pad.up ? -1 : 0) + (pad.down ? 1 : 0);

          // choose analog if outside deadzone, else d-pad, else keyboard
          const mag = Math.hypot(ax, ay);
          if (mag > DEADZONE) {
            // normalize (optional) so full deflection is consistent
            const nx = ax / mag;
            const ny = ay / mag;

            // Use magnitude for speed scaling, but clamp to [0..1]
            const s = Math.min(1, mag);

            vx = nx * (ROBOT_SPEED * s);
            vy = ny * (ROBOT_SPEED * s);
          } else if (dpx !== 0 || dpy !== 0) {
            // normalize diagonal for dpad
            let dx = dpx, dy = dpy;
            if (dx !== 0 && dy !== 0) {
              const inv = 1 / Math.sqrt(2);
              dx *= inv; dy *= inv;
            }
            vx = dx * ROBOT_SPEED;
            vy = dy * ROBOT_SPEED;
          }

          // Spin:  right stick
          const rx = pad.axes.length > 2 ? pad.axes[2].getValue() : 0;

          let pOmega = 0;
          if (Math.abs(rx) > DEADZONE) pOmega = rx;

          if (pOmega !== 0) {
            omega = pOmega * ROBOT_SPIN_SPEED;
          }

          // Shoot: A / Cross is usually button 0
          //const a = pad.buttons.length > 0 ? pad.buttons[0].pressed : false;
          //shoot = shoot || a;

          // Optional: also allow Right Trigger to shoot if you want
          const rt = pad.buttons.length > 7 ? pad.buttons[7].value : 0; // may be 0..1
          shoot = shoot || (rt > 0.5);
        }

        return {vx, vy, omega, shoot};
      }
    } // end of HumanController


    // -----------------------------
    // CURSOR CONTROLLER
    // -----------------------------
    class CursorController extends BaseController {
      constructor() {
        super();
        this.driveDeadband = ROBOT_W * 0.45;
        this.turnDeadbandRad = 0.08;
        this.kTurn = 5.0;
      }

      getCommands(scene, robot, delta) {
        if (scene.matchOver) return {vx: 0, vy: 0, omega: 0, shoot: false};

        const p = scene.input?.activePointer;
        if (!p) return {vx: 0, vy: 0, omega: 0, shoot: false};

        // worldX/worldY are robust with camera and CSS-scaled canvases.
        const px = Number.isFinite(p.worldX) ? p.worldX : p.x;
        const py = Number.isFinite(p.worldY) ? p.worldY : p.y;
        const onField = px >= 0 && px <= FIELD_W && py >= 0 && py <= FIELD_H;

        const shoot = !!(
          p.isDown ||
          p.leftButtonDown?.() ||
          p.middleButtonDown?.() ||
          p.rightButtonDown?.()
        );

        // Ignore clicks in UI area (e.g., Start/Stop button) so they do not fire shots.
        if (!onField) return {vx: 0, vy: 0, omega: 0, shoot: false};

        const rx = robot.body.position.x;
        const ry = robot.body.position.y;
        const dx = px - rx;
        const dy = py - ry;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.driveDeadband) {
          return {vx: 0, vy: 0, omega: 0, shoot};
        }

        const nx = dx / dist;
        const ny = dy / dist;

        const slowRadius = ROBOT_W * 2.0;
        const speedScale = Phaser.Math.Clamp((dist - this.driveDeadband) / slowRadius, 0.25, 1.0);
        const vx = nx * ROBOT_SPEED * speedScale;
        const vy = ny * ROBOT_SPEED * speedScale;

        const desiredForwardAng = Math.atan2(dy, dx);
        const desiredBodyAng = desiredForwardAng - FORWARD_OFFSET;
        const turnErr = Phaser.Math.Angle.Wrap(desiredBodyAng - robot.body.angle);
        const omega = (Math.abs(turnErr) < this.turnDeadbandRad)
          ? 0
          : Phaser.Math.Clamp(turnErr * this.kTurn, -ROBOT_SPIN_SPEED, ROBOT_SPIN_SPEED);

        return {vx, vy, omega, shoot};
      }
    } // end of CursorController

    // -----------------------------
    // AUTO BASE CONTROLLER
    // Shared auto movement + anti-stuck + fuel query helpers.
    // -----------------------------
    class AutoBaseController extends BaseController {
      constructor(alliance /* "Blue" | "Red" */) {
        super();
        this.alliance = alliance;

        this.arriveDist = 24;
        this.pickupDist = 14;
        this.maxSpeed = ROBOT_SPEED * 0.92;
        this.kTurn = 6.0;

        // Anti-stuck recovery
        this.lastPos = null;
        this.stuckMs = 0;
        this.stuckTriggerMs = 1000;
        this.minMovePx = 1.6;
        this.unstuckMsRemaining = 0;
        this.unstuckCmd = {vx: 0, vy: 0, omega: 0, shoot: false};
        this.unstuckMinMs = 320;
        this.unstuckMaxMs = 760;
        this.unstuckSpeedMin = ROBOT_SPEED * 0.75;
        this.unstuckSpeedMax = ROBOT_SPEED * 1.05;

      }

      driveTo(robot, tx, ty) {
        const rx = robot.body.position.x;
        const ry = robot.body.position.y;
        const dx = tx - rx;
        const dy = ty - ry;
        const dist = Math.hypot(dx, dy);

        if (dist <= this.arriveDist) return {vx: 0, vy: 0, omega: 0, arrived: true};

        const nx = dx / Math.max(1e-6, dist);
        const ny = dy / Math.max(1e-6, dist);
        const vx = nx * this.maxSpeed;
        const vy = ny * this.maxSpeed;

        const travelHeading = Math.atan2(dy, dx);
        const desiredBodyAng = travelHeading - FORWARD_OFFSET;
        const err = Phaser.Math.Angle.Wrap(desiredBodyAng - robot.body.angle);
        const omega = Phaser.Math.Clamp(err * this.kTurn, -ROBOT_SPIN_SPEED, ROBOT_SPIN_SPEED);

        return {vx, vy, omega, arrived: false};
      }

      applyAntiStuck(robot, plannedCmd, dtMs, fuelCount) {
        const rx = robot.body.position.x;
        const ry = robot.body.position.y;
        const speedCmd = Math.hypot(plannedCmd.vx || 0, plannedCmd.vy || 0);
        const turningCmd = Math.abs(plannedCmd.omega || 0);
        const intendsMotion = speedCmd > 0.2 || turningCmd > 0.01;

        if (!this.lastPos) {
          this.lastPos = {x: rx, y: ry};
          this.stuckMs = 0;
          return plannedCmd;
        }

        const movedPx = Phaser.Math.Distance.Between(rx, ry, this.lastPos.x, this.lastPos.y);
        this.lastPos = {x: rx, y: ry};

        if (intendsMotion && movedPx < this.minMovePx) {
          this.stuckMs += dtMs;
        } else {
          this.stuckMs = 0;
        }

        if (this.stuckMs < this.stuckTriggerMs) return plannedCmd;

        this.stuckMs = 0;
        const escapeAng = Phaser.Math.FloatBetween(-Math.PI, Math.PI);
        const escapeSpeed = Phaser.Math.FloatBetween(this.unstuckSpeedMin, this.unstuckSpeedMax);
        const escapeOmega = Phaser.Math.FloatBetween(-ROBOT_SPIN_SPEED, ROBOT_SPIN_SPEED);

        this.unstuckCmd = {
          vx: Math.cos(escapeAng) * escapeSpeed,
          vy: Math.sin(escapeAng) * escapeSpeed,
          omega: escapeOmega,
          shoot: fuelCount > 0
        };
        this.unstuckMsRemaining = Phaser.Math.Between(this.unstuckMinMs, this.unstuckMaxMs);
        return this.unstuckCmd;
      }

      getAllianceReentryPoint(alliance, yHint) {
        const y = Phaser.Math.Clamp(yHint, 24, FIELD_H - 24);
        if (alliance === "Blue") return {x: BLUE_LINE_X + 70, y};
        return {x: RED_LINE_X - 70, y};
      }

      getNeutralAnchor(yHint) {
        return {
          x: (RED_LINE_X + BLUE_LINE_X) / 2,
          y: Phaser.Math.Clamp(yHint, 24, FIELD_H - 24)
        };
      }

      countGroundFuelInZone(scene, zoneId) {
        let count = 0;
        for (const f of scene.fuels) {
          if (!f.body) continue;
          if (f.body.isAirborne) continue;
          if (scene.getZoneForX(f.body.position.x).id === zoneId) count++;
        }
        return count;
      }

      findNearestGroundFuelInZone(scene, zoneId, x, y) {
        let best = null;
        let bestD2 = Infinity;

        for (const f of scene.fuels) {
          if (!f.body) continue;
          if (f.body.isAirborne) continue;
          if (scene.getZoneForX(f.body.position.x).id !== zoneId) continue;

          const dx = f.body.position.x - x;
          const dy = f.body.position.y - y;
          const d2 = dx * dx + dy * dy;

          if (d2 < bestD2) {
            bestD2 = d2;
            best = f;
          }
        }
        return best;
      }
    } // end of AutoBaseController

    // -----------------------------
    // FUEL SEEKER CONTROLLER
    // Goal: maximize scored fuel quickly with hub-aware behavior
    // -----------------------------
    class FuelSeekerController extends AutoBaseController {
      constructor(alliance /* "Blue" | "Red" */) {
        super(alliance);
        this.unloading = false;
        this.unloadExitCount = 3;
        this.hubShootStandoffDist = 72;
        this.hubShootLateralClamp = 96;
      }

      getHubShootPoint(robot, hubPoint) {
        const dir = (this.alliance === "Blue") ? 1 : -1;
        const x = hubPoint.x + (dir * this.hubShootStandoffDist);
        const yOffset = Phaser.Math.Clamp(
          robot.body.position.y - hubPoint.y,
          -this.hubShootLateralClamp,
          this.hubShootLateralClamp
        );
        const y = Phaser.Math.Clamp(hubPoint.y + yOffset, 24, FIELD_H - 24);
        return {x, y};
      }

      getCommands(scene, robot, delta) {
        if (scene.matchOver) return {vx: 0, vy: 0, omega: 0, shoot: false};
        const dtMs = Math.max(1, delta || 16.7);
        const fuelCount = robot.state?.fuelStore?.length ?? 0;

        if (this.unstuckMsRemaining > 0) {
          this.unstuckMsRemaining -= dtMs;
          this.lastPos = {x: robot.body.position.x, y: robot.body.position.y};
          return {
            vx: this.unstuckCmd.vx,
            vy: this.unstuckCmd.vy,
            omega: this.unstuckCmd.omega,
            shoot: fuelCount > 0
          };
        }

        const allianceZoneId = (this.alliance === "Blue") ? ZoneId.BLUE : ZoneId.RED;
        const currentZoneId = scene.getZoneForX(robot.body.position.x).id;
        const hub = (this.alliance === "Blue") ? scene.blueHub : scene.redHub;
        const hubPoint = scene.getAllianceHubPoint(this.alliance);
        const hubShootPoint = this.getHubShootPoint(robot, hubPoint);

        const allianceFuelCount = this.countGroundFuelInZone(scene, allianceZoneId);
        const neutralFuelCount = this.countGroundFuelInZone(scene, ZoneId.NEUTRAL);
        let cmd = {vx: 0, vy: 0, omega: 0, shoot: false};

        // Hub active:
        // - Prefer alliance-zone fuel and score from alliance zone.
        // - If alliance is dry, load in neutral then return alliance to score.
        if (hub.active) {
          // Sticky unload run: once we commit a full load to scoring, keep unloading
          // until mostly empty to prevent line-bounce oscillation.
          if (fuelCount >= MAX_STORAGE) this.unloading = true;
          if (this.unloading && fuelCount <= this.unloadExitCount) this.unloading = false;

          if (this.unloading) {
            if (currentZoneId !== allianceZoneId) {
              const reentry = this.getAllianceReentryPoint(this.alliance, robot.body.position.y);
              const move = this.driveTo(robot, reentry.x, reentry.y);
              cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: false};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }
            const move = this.driveTo(robot, hubShootPoint.x, hubShootPoint.y);
            cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: fuelCount > 0};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }

          if (allianceFuelCount > 0) {
            if (currentZoneId !== allianceZoneId) {
              const reentry = this.getAllianceReentryPoint(this.alliance, robot.body.position.y);
              const move = this.driveTo(robot, reentry.x, reentry.y);
              cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: false};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }

            const nearestAllianceFuel = this.findNearestGroundFuelInZone(
              scene,
              allianceZoneId,
              robot.body.position.x,
              robot.body.position.y
            );

            if (nearestAllianceFuel) {
              const dist = Phaser.Math.Distance.Between(
                robot.body.position.x, robot.body.position.y,
                nearestAllianceFuel.body.position.x, nearestAllianceFuel.body.position.y
              );

              const shoot = fuelCount > 0;
              if (dist <= this.pickupDist) {
                cmd = {vx: 0, vy: 0, omega: 0, shoot};
                return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
              }

              const move = this.driveTo(robot, nearestAllianceFuel.body.position.x, nearestAllianceFuel.body.position.y);
              cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }

            if (fuelCount > 0) {
              const move = this.driveTo(robot, hubShootPoint.x, hubShootPoint.y);
              cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: true};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }
            cmd = {vx: 0, vy: 0, omega: 0, shoot: false};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }

          // Alliance zone empty: load neutral to full, then return alliance to score.
          if (fuelCount >= MAX_STORAGE) {
            if (currentZoneId !== allianceZoneId) {
              const reentry = this.getAllianceReentryPoint(this.alliance, robot.body.position.y);
              const move = this.driveTo(robot, reentry.x, reentry.y);
              cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: false};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }
            const move = this.driveTo(robot, hubShootPoint.x, hubShootPoint.y);
            cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: fuelCount > 0};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }

          if (currentZoneId !== ZoneId.NEUTRAL) {
            const neutralPoint = this.getNeutralAnchor(robot.body.position.y);
            const move = this.driveTo(robot, neutralPoint.x, neutralPoint.y);
            cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: false};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }

          const nearestNeutralFuel = this.findNearestGroundFuelInZone(
            scene,
            ZoneId.NEUTRAL,
            robot.body.position.x,
            robot.body.position.y
          );

          if (nearestNeutralFuel) {
            const dist = Phaser.Math.Distance.Between(
              robot.body.position.x, robot.body.position.y,
              nearestNeutralFuel.body.position.x, nearestNeutralFuel.body.position.y
            );
            if (dist <= this.pickupDist) {
              cmd = {vx: 0, vy: 0, omega: 0, shoot: false};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }
            const move = this.driveTo(robot, nearestNeutralFuel.body.position.x, nearestNeutralFuel.body.position.y);
            cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: false};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }

          // No neutral fuel found: return alliance if loaded, otherwise hold neutral.
          if (fuelCount > 0) {
            const reentry = this.getAllianceReentryPoint(this.alliance, robot.body.position.y);
            const move = this.driveTo(robot, reentry.x, reentry.y);
            cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: false};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }
          cmd = {vx: 0, vy: 0, omega: 0, shoot: false};
          return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
        }

        // Hub inactive:
        // Live in neutral and keep scooping/shooting.
        if (currentZoneId !== ZoneId.NEUTRAL) {
          const neutralPoint = this.getNeutralAnchor(robot.body.position.y);
          const move = this.driveTo(robot, neutralPoint.x, neutralPoint.y);
          cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: fuelCount > 0};
          return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
        }

        if (neutralFuelCount > 0) {
          const nearestNeutralFuel = this.findNearestGroundFuelInZone(
            scene,
            ZoneId.NEUTRAL,
            robot.body.position.x,
            robot.body.position.y
          );
          if (nearestNeutralFuel) {
            const dist = Phaser.Math.Distance.Between(
              robot.body.position.x, robot.body.position.y,
              nearestNeutralFuel.body.position.x, nearestNeutralFuel.body.position.y
            );
            if (dist <= this.pickupDist) {
              cmd = {vx: 0, vy: 0, omega: 0, shoot: fuelCount > 0};
              return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
            }
            const move = this.driveTo(robot, nearestNeutralFuel.body.position.x, nearestNeutralFuel.body.position.y);
            cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot: fuelCount > 0};
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }
        }

        cmd = {vx: 0, vy: 0, omega: 0, shoot: fuelCount > 0};
        return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
      }
    } // end of FuelSeekerController

    // -----------------------------
    // ADAPTIVE HUB CONTROLLER
    // Goal:
    // - Hub active: score aggressively (FuelSeeker behavior).
    // - Hub inactive: raid opponent-zone fuel while avoiding robot contact.
    // -----------------------------
    class AdaptiveHubController extends AutoBaseController {
      constructor(alliance /* "Blue" | "Red" */) {
        super(alliance);
        this.scorer = new FuelSeekerController(alliance);
        this.maxSpeed = ROBOT_SPEED * 0.95;
        this.arriveDist = 18;
        this.avoidSoftDist = ROBOT_W * 2.1;
        this.avoidHardDist = ROBOT_W * 1.2;
        this.avoidGain = 0.85;
      }

      getOpponentRobot(scene, robot) {
        return (robot.name === "Red") ? scene.blueRobot : scene.redRobot;
      }

      getOpponentZoneId() {
        return (this.alliance === "Blue") ? ZoneId.RED : ZoneId.BLUE;
      }

      getOpponentZoneAnchor(yHint) {
        const y = Phaser.Math.Clamp(yHint, 28, FIELD_H - 28);
        if (this.alliance === "Blue") return {x: RED_LINE_X - 40, y};
        return {x: BLUE_LINE_X + 40, y};
      }

      applySeparation(robot, opponent, cmd) {
        if (!opponent?.body) return cmd;

        const rx = robot.body.position.x;
        const ry = robot.body.position.y;
        const ox = opponent.body.position.x;
        const oy = opponent.body.position.y;
        const dx = rx - ox;
        const dy = ry - oy;
        const dist = Math.hypot(dx, dy);

        if (dist >= this.avoidSoftDist) return cmd;

        const nx = dx / Math.max(1e-6, dist);
        const ny = dy / Math.max(1e-6, dist);

        if (dist < this.avoidHardDist) {
          return {
            vx: nx * this.maxSpeed,
            vy: ny * this.maxSpeed,
            omega: cmd.omega,
            shoot: cmd.shoot
          };
        }

        const t = Phaser.Math.Clamp((this.avoidSoftDist - dist) / (this.avoidSoftDist - this.avoidHardDist), 0, 1);
        const repelScale = this.maxSpeed * this.avoidGain * t;
        const vx = cmd.vx + (nx * repelScale);
        const vy = cmd.vy + (ny * repelScale);

        const mag = Math.hypot(vx, vy);
        const speedScale = (mag > this.maxSpeed) ? (this.maxSpeed / mag) : 1;
        return {
          vx: vx * speedScale,
          vy: vy * speedScale,
          omega: cmd.omega,
          shoot: cmd.shoot
        };
      }

      getDefenseCommands(scene, robot, delta) {
        const dtMs = Math.max(1, delta || 16.7);
        const fuelCount = robot.state?.fuelStore?.length ?? 0;
        const opponent = this.getOpponentRobot(scene, robot);

        if (this.unstuckMsRemaining > 0) {
          this.unstuckMsRemaining -= dtMs;
          this.lastPos = {x: robot.body.position.x, y: robot.body.position.y};
          const cmd = {
            vx: this.unstuckCmd.vx,
            vy: this.unstuckCmd.vy,
            omega: this.unstuckCmd.omega,
            shoot: fuelCount > 0
          };
          return this.applySeparation(robot, opponent, cmd);
        }

        const opponentZoneId = this.getOpponentZoneId();
        const currentZoneId = scene.getZoneForX(robot.body.position.x).id;
        const shoot = fuelCount > 0;
        let cmd = {vx: 0, vy: 0, omega: 0, shoot};

        if (currentZoneId !== opponentZoneId) {
          const anchor = this.getOpponentZoneAnchor(robot.body.position.y);
          const move = this.driveTo(robot, anchor.x, anchor.y);
          cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot};
          cmd = this.applySeparation(robot, opponent, cmd);
          return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
        }

        const nearestOpponentFuel = this.findNearestGroundFuelInZone(
          scene,
          opponentZoneId,
          robot.body.position.x,
          robot.body.position.y
        );

        if (nearestOpponentFuel) {
          const dist = Phaser.Math.Distance.Between(
            robot.body.position.x, robot.body.position.y,
            nearestOpponentFuel.body.position.x, nearestOpponentFuel.body.position.y
          );

          if (dist <= this.pickupDist) {
            cmd = {vx: 0, vy: 0, omega: 0, shoot};
            cmd = this.applySeparation(robot, opponent, cmd);
            return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
          }

          const move = this.driveTo(robot, nearestOpponentFuel.body.position.x, nearestOpponentFuel.body.position.y);
          cmd = {vx: move.vx, vy: move.vy, omega: move.omega, shoot};
          cmd = this.applySeparation(robot, opponent, cmd);
          return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
        }

        // No target fuel visible in opponent zone: hold a safe raiding lane.
        const hold = this.getOpponentZoneAnchor(FIELD_H / 2);
        const holdMove = this.driveTo(robot, hold.x, hold.y);
        cmd = {vx: holdMove.vx, vy: holdMove.vy, omega: holdMove.omega, shoot};
        cmd = this.applySeparation(robot, opponent, cmd);
        return this.applyAntiStuck(robot, cmd, dtMs, fuelCount);
      }

      getCommands(scene, robot, delta) {
        if (scene.matchOver) return {vx: 0, vy: 0, omega: 0, shoot: false};
        const hub = (this.alliance === "Blue") ? scene.blueHub : scene.redHub;
        if (hub.active) {
          return this.scorer.getCommands(scene, robot, delta);
        }
        return this.getDefenseCommands(scene, robot, delta);
      }
    } // end of AdaptiveHubController

    // -----------------------------
    // MAIN SCENE
    // -----------------------------
    class MainScene extends Phaser.Scene {
      constructor() {
        super("MainScene");
        this.fuels = [];

        this.RobotState = class RobotState {
          constructor() {
            this.fuelStore = []; // array of Fuel objects
            this.score = 0;
            this.lastShotTime = 0;
            this.lastNoAmmoMs = 0;
          }
        };
      }

      preload() {
        this.load.image("rebuiltLogo", "assets/RebuiltReduxLogo.jpeg");
        this.load.audio("matchStart", "assets/audio/match/matchStart.wav");
        this.load.audio("matchEnd", "assets/audio/match/matchEnd.wav");
        this.load.audio("matchResume", "assets/audio/match/matchResume.wav");
        this.load.audio("matchShiftChange", "assets/audio/match/matchShiftChange.wav");
        this.load.audio("matchWarningSonar", "assets/audio/match/matchWarningSonar.wav");
      }

      create() {
        // Matter world bounds (field only)
        this.matter.world.setBounds(0, 0, FIELD_W, FIELD_H, 20, true, true, true, true);

        // Field carpet (behind everything)
        const cx = FIELD_W / 2;
        const cy = FIELD_H / 2;
        this.fieldRect = this.add.rectangle(cx, cy, FIELD_W, FIELD_H, 0x707175).setDepth(-1000);

        // Logo on carpet, centered, beneath everything else
        this.fieldLogo = this.add.image(cx, cy, "rebuiltLogo")
          .setOrigin(0.5)
          .setDepth(-999)   // above carpet, below all gameplay/UI
          .setAlpha(0.12)  // optional: make it look printed, not a sticker
          .setScale(0.20);

        // Sleep config
        const engine = this.matter.world.engine;
        engine.enableSleeping = true;
        engine.positionIterations = 6;
        engine.velocityIterations = 4;

        // Match state
        this.matchStartMs = Date.now();
        this.matchOver = false;

        // Pause/run state
        this.isRunning = false;
        this.hasMatchStarted = false;
        this.pausedTotalMs = 0;
        this.pauseStartMs = null;

        // Sound one-shot state
        this.lastPlayedTimeframeName = null;
        this.lastPlayedTransitionWarningFor = null;
        this.hasPlayedMatchEndSound = false;

        // Timeframe state
        this.currentTimeframeIndex = -1;
        this.autoLeader = "TIE"; // decided at end of AUTO

        // -----------------------------
        // SCOREBOARD UI (below field)
        // -----------------------------
        const uiTop = FIELD_H;
        const uiBottom = uiTop + UI_H;

        this.uiG = this.add.graphics().setDepth(1000);
        this.uiG.fillStyle(0x0b0f14, 1);
        this.uiG.fillRect(0, uiTop, FIELD_W, UI_H);

        // Zones
        this.zones = [
          new Zone(ZoneId.RED, 0, RED_LINE_X),
          new Zone(ZoneId.NEUTRAL, RED_LINE_X, BLUE_LINE_X),
          new Zone(ZoneId.BLUE, BLUE_LINE_X, FIELD_W),
        ];

        // Fuel counts ON the field (above carpet/logo, under gameplay)
        const zoneCountY = FIELD_H - 24;          // inside the field near the top
        const zoneCountDepth = -950;    // between carpet (-1000/-999) and gameplay

        this.zoneCountText = {};
        for (const z of this.zones) {
          this.zoneCountText[z.id] = this.add.text(z.centerX(), zoneCountY, "0", {
            fontFamily: "monospace",
            fontSize: "20px",
            fontStyle: "bold",
            color: "#ffdd55",
          })
            .setOrigin(0.5, 0.5)
            .setDepth(zoneCountDepth);
        }

        // Panels
        const panelH = 96;
        const panelY = uiTop;

        this.redScoreText = this.add.text(RED_LINE_X, FIELD_H / 2, "0", {
          fontFamily: "monospace",
          fontSize: "32px",
          fontStyle: "bold",
          color: "#ffffff",
        }).setOrigin(0.5, 0.5).setDepth(1001);

        this.blueScoreText = this.add.text(BLUE_LINE_X, FIELD_H / 2, "0", {
          fontFamily: "monospace",
          fontSize: "32px",
          fontStyle: "bold",
          color: "#ffffff",
        }).setOrigin(0.5, 0.5).setDepth(1001);

        // Timer box
        const timerBoxW = 144;
        const timerBoxH = 72;
        const timerX0 = (FIELD_W - timerBoxW) / 2;
        const timerY0 = panelY;

        this.uiG.fillStyle(0xe7e7e7, 1);
        this.uiG.fillRoundedRect(timerX0, timerY0, timerBoxW, timerBoxH, 6);

        this.uiG.lineStyle(2, 0xaaaaaa, 1);
        this.uiG.strokeRoundedRect(timerX0, timerY0, timerBoxW, timerBoxH, 6);

        const timerCenterX = FIELD_W / 2;
        const headerRowW = 106;
        const headerLeftX = timerCenterX - (headerRowW / 2);
        const headerRightX = timerCenterX + (headerRowW / 2);
        const timeframeCountdownChipW = 46;
        const timeframeCountdownChipH = 22;
        const timeframeCountdownX = headerRightX - (timeframeCountdownChipW / 2);
        const timeframeCountdownY = timerY0 + 12;

        this.timeframeText = this.add.text(headerLeftX, timerY0 + 12, "AUTO", {
          fontFamily: "monospace",
          fontSize: "18px",
          fontStyle: "bold",
          color: "#111111",
        }).setOrigin(0, 0.5).setDepth(1002);

        this.timeframeCountdownChip = this.add.rectangle(
          timeframeCountdownX,
          timeframeCountdownY,
          timeframeCountdownChipW,
          timeframeCountdownChipH,
          0xbbbbbb,
          1
        ).setDepth(1001);

        this.timeframeCounterText = this.add.text(timeframeCountdownX, timerY0 + 12, "0:20", {
          fontFamily: "monospace",
          fontSize: "16px",
          fontStyle: "bold",
          color: "#111111",
        }).setOrigin(0.5, 0.5).setDepth(1002);

        this.timeText = this.add.text(FIELD_W / 2, timerY0 + 48, "2:30", {
          fontFamily: "monospace",
          fontSize: "44px",
          fontStyle: "bold",
          color: "#111111",
        }).setOrigin(0.5, 0.5).setDepth(1002);

        // Start/Stop button
        const btnY = uiBottom - 18;
        this.toggleBtnBg = this.add.rectangle(FIELD_W / 2, btnY, 170, 32, 0x222222, 1)
          .setStrokeStyle(2, 0x666666, 1)
          .setDepth(1000)
          .setInteractive({useHandCursor: true});

        this.toggleBtnText = this.add.text(FIELD_W / 2, btnY, "Start", {
          fontFamily: "monospace",
          fontSize: "16px",
          fontStyle: "bold",
          color: "#ffffff",
        }).setOrigin(0.5, 0.5).setDepth(1001);

        this.toggleBtnBg.on("pointerdown", () => this.toggleRun());
        this.toggleBtnText.setInteractive({useHandCursor: true});
        this.toggleBtnText.on("pointerdown", () => this.toggleRun());

        // Start paused
        this.pauseStartMs = Date.now();
        this.matter.world.pause();

        // Border around field
        const border = this.add.graphics();
        border.lineStyle(4, 0x2d2d2d, 1);
        border.strokeRect(2, 2, FIELD_W - 4, FIELD_H - 4);

        // Collision categories
        const CAT_FUEL = this.matter.world.nextCategory();
        const CAT_ROBOT = this.matter.world.nextCategory();
        const CAT_FIELD_WALLS = this.matter.world.nextCategory();
        const CAT_HUBS = this.matter.world.nextCategory();
        const CAT_SENSOR = this.matter.world.nextCategory();

        this.CAT_FUEL = CAT_FUEL;
        this.CAT_ROBOT = CAT_ROBOT;
        this.CAT_FIELD_WALLS = CAT_FIELD_WALLS;
        this.CAT_HUBS = CAT_HUBS;
        this.CAT_SENSOR = CAT_SENSOR;

        // Outer boundary walls
        const wallThickness = 24;
        const walls = [
          this.matter.add.rectangle(FIELD_W / 2, -wallThickness / 2, FIELD_W, wallThickness, {isStatic: true}),
          this.matter.add.rectangle(FIELD_W / 2, FIELD_H + wallThickness / 2, FIELD_W, wallThickness, {isStatic: true}),
          this.matter.add.rectangle(-wallThickness / 2, FIELD_H / 2, wallThickness, FIELD_H, {isStatic: true}),
          this.matter.add.rectangle(FIELD_W + wallThickness / 2, FIELD_H / 2, wallThickness, FIELD_H, {isStatic: true}),
        ];
        walls.forEach((w) => {
          w.collisionFilter.category = CAT_FIELD_WALLS;
          w.collisionFilter.mask = CAT_FUEL | CAT_ROBOT;
        });

        // Reference lines (zones)
        this.refLinesG = this.add.graphics().setDepth(1);
        this.refLinesG.lineStyle(3, 0xff3333, 1);
        this.refLinesG.lineBetween(RED_LINE_X, 0, RED_LINE_X, FIELD_H);
        this.refLinesG.lineStyle(3, 0x2a7fff, 1);
        this.refLinesG.lineBetween(BLUE_LINE_X, 0, BLUE_LINE_X, FIELD_H);

        // Grid placement (centered)
        const gridW = (GRID_COLS - 1) * FUEL_SPACING_X;
        const gridH = (GRID_ROWS - 1) * FUEL_SPACING_Y + GRID_MID_GAP_PX;
        this.gridStartX = FIELD_W / 2 - gridW / 2;
        this.gridStartY = FIELD_H / 2 - gridH / 2;

        // Hex radius inside hub
        const maxRByWidth = (HUB_W - 2 * HUB_HEX_GAP_PX) / 2;
        const maxRByHeight = (HUB_H - 2 * HUB_HEX_GAP_PX) / Math.sqrt(3);
        this.hubHexR = Math.min(maxRByWidth, maxRByHeight);

        // Hubs
        this.redHub = new Hub(this, {
          name: "Red",
          cx: RED_LINE_X,
          cy: FIELD_H / 2,
          colorFill: 0xff3333,
          colorLine: 0xff3333,
          sensorTagName: "isRedHubSensor",
        });

        this.blueHub = new Hub(this, {
          name: "Blue",
          cx: BLUE_LINE_X,
          cy: FIELD_H / 2,
          colorFill: 0x2a7fff,
          colorLine: 0x2a7fff,
          sensorTagName: "isBlueHubSensor",
        });

        // Spawn field fuel (adds Fuel objects to master list)
        this.spawnFuelGrid();
        this.spawnFuelDepots();

        // Controls (SWAPPED):
        // WASD/QE/Space = RED
        // IJKL/UO/Enter = BLUE
        this.keys = {
          wasd: this.input.keyboard.addKeys("W,A,S,D,Q,E"),
          space: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),

          ijkl: this.input.keyboard.addKeys("I,J,K,L,U,O"),
          enter: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER),

          reset: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.R),
        };


        // Robots
        const redPose = this.getRobotStartPoseForAlliance("Red");
        this.redRobot = new Robot(this, {
          name: "Red",
          x: redPose.x,
          y: redPose.y,
          color: 0xff3333,
          preloadedFuel: PRELOADED_FUEL,
          controls: {
            up: this.keys.wasd.W, left: this.keys.wasd.A, down: this.keys.wasd.S, right: this.keys.wasd.D,
            spinL: this.keys.wasd.Q, spinR: this.keys.wasd.E,
            shootKey: this.keys.space
          }
        });

        const bluePose = this.getRobotStartPoseForAlliance("Blue");
        this.blueRobot = new Robot(this, {
          name: "Blue",
          x: bluePose.x,
          y: bluePose.y,
          color: 0x2a7fff,
          preloadedFuel: PRELOADED_FUEL,
          controls: {
            up: this.keys.ijkl.I, left: this.keys.ijkl.J, down: this.keys.ijkl.K, right: this.keys.ijkl.L,
            spinL: this.keys.ijkl.U, spinR: this.keys.ijkl.O,
            shootKey: this.keys.enter
          }
        });


        // Face inward
        this.blueRobot.setPose(bluePose);
        this.redRobot.setPose(redPose);

        // Initialize robot controllers from HTML dropdowns
        this.initControllerDropdowns();

        // Preload fuel as real Fuel objects in master list, but stashed in robots
        this.preloadRobotFuel();

        // Collision scoring: hex sensors
        const isBlueSensor = (x) => x && (x.isBlueHubSensor || (x.parent && x.parent.isBlueHubSensor));
        const isRedSensor = (x) => x && (x.isRedHubSensor || (x.parent && x.parent.isRedHubSensor));
        const isFuel = (x) => x && (x.isFuel || (x.parent && x.parent.isFuel));

        this.matter.world.on("collisionstart", (event) => {
          if (this.matchOver) return;

          const nowMs = Date.now();

          // Helper: intake sensor can be a part; the flag is usually on the part
          const isIntakeSensor = (body) => !!(body && (body.isIntakeSensor || body.parent?.isIntakeSensor));

          // Helper: get robot for an intake sensor
          const robotForIntakeSensor = (body) => {
            const sensor = body.isIntakeSensor ? body : (body.parent?.isIntakeSensor ? body.parent : body);
            const name = body.robotName || body.parent?.robotName || sensor?.robotName;

            // Prefer name lookup if present
            if (name) {
              if (this.blueRobot && this.blueRobot.name === name) return this.blueRobot;
              if (this.redRobot && this.redRobot.name === name) return this.redRobot;
            }

            // Fallback: if you didn’t set robotName, you can still map by identity if you store it
            return null;
          };

          for (const pair of event.pairs) {
            const a = pair.bodyA;
            const b = pair.bodyB;

            // Normalize fuel to its root body (supports compound parts)
            const fuelBody = isFuel(a) ? (a.parent || a) : (isFuel(b) ? (b.parent || b) : null);
            if (!fuelBody) continue;

            const otherBody = (fuelBody === (a.parent || a)) ? b : a;

            // ------------------------------------------------------------
            // 1) HUB SENSOR HANDLING (your existing logic, unchanged)
            //    Only score/capture if airborne (wasShot)
            // ------------------------------------------------------------
            if (fuelBody.wasShot) {
              let hub = null;
              let scoringRobot = null;

              if (isBlueSensor(otherBody)) {
                hub = this.blueHub;
                scoringRobot = this.blueRobot;
              } else if (isRedSensor(otherBody)) {
                hub = this.redHub;
                scoringRobot = this.redRobot;
              } else {
                continue;
              }

              // Score only if hub is active (still accept/capture always)
              if (hub.active) scoringRobot.state.score += 1;

              const fuelObj = fuelBody.fuelObj;
              if (fuelObj) {
                hub.captureFuel(fuelObj, nowMs);
              } else {
                // fallback: should not happen
                this.deleteFuelBody(fuelBody);
              }

              continue; // IMPORTANT: if it hit a hub sensor, don’t also intake it
            }

            // ------------------------------------------------------------
            // 2) INTAKE SENSOR HANDLING (new)
            //    Touch-n-go: only when fuel enters intake sensor
            // ------------------------------------------------------------
            if (!isIntakeSensor(otherBody)) continue;

            // Don’t intake airborne / shot fuel (keeps roles clean)
            if (fuelBody.isAirborne) continue;

            const robotObj = robotForIntakeSensor(otherBody);
            if (!robotObj) continue;

            if (robotObj.state.fuelStore.length >= MAX_STORAGE) continue;

            const fuelObj = fuelBody.fuelObj;
            if (!fuelObj) {
              // If something went weird, clean it up safely
              this.deleteFuelBody(fuelBody);
              continue;
            }

            // Tiny cooldown prevents double-grabs from multiple contact pairs
            if (fuelBody._noIntakeUntilMs && nowMs < fuelBody._noIntakeUntilMs) continue;
            fuelBody._noIntakeUntilMs = nowMs + 120;

            // Capture into robot storage (your existing pattern)
            fuelObj.stash(robotObj.name);
            robotObj.state.fuelStore.push(fuelObj);
          }
        });  // end of collision handler

        // Small HUD (optional)
        /*
        this.HUDtext = this.add.text(10, 10, "", {
          fontFamily: "monospace",
          fontSize: "14px",
          color: "#FFFFFF",
          backgroundColor: "rgba(0,0,0,0.4)",
          padding: {x: 8, y: 6},
        }).setDepth(60);
        */

        // Initialize time display
        this.setTimeUI(MATCH_TIME_S);
        this.applyTimeframeForElapsedS(0);
        this.setTimeframeCountdownUI(this.getTimeframeRemainingS(0));

        // Gamepad support
        this.input.gamepad.start();

        // Optional: log connections
        this.input.gamepad.on("connected", (pad) => {
          console.log("Gamepad connected:", pad.id, "index:", pad.index);
        });
        this.input.gamepad.on("disconnected", (pad) => {
          console.log("Gamepad disconnected:", pad.id, "index:", pad.index);
        });

        // If you have 2 robots, assign pad indices (simple v1)
        // Blue -> pad 0, Red -> pad 1 (change if you prefer)
        this.redRobot.gamepadIndex = 0;
        this.blueRobot.gamepadIndex = 1;
      } // end of create()

      // -----------------------------
      // CONTROLLER DROPDOWNS
      // -----------------------------
      initControllerDropdowns() {
        const redSel = document.getElementById("redControllerSelect");
        const blueSel = document.getElementById("blueControllerSelect");
        const redHint = document.getElementById("redKbHint");
        const blueHint = document.getElementById("blueKbHint");

        if (!redSel || !blueSel) {
          console.warn("Controller selects not found (redControllerSelect / blueControllerSelect).");
          return;
        }

        const makeController = (robot, value) => {
          switch (value) {
            case "cursor":
              return new CursorController();
            case "fuelSeeker":
              return new FuelSeekerController(robot.name);
            case "adaptiveHub":
              return new AdaptiveHubController(robot.name);
            case "human":
            default:
              return new HumanController();
          }
        };
        `RED: WASD/QE + Space   BLUE: IJKL/UO + Enter   Reset: R`

        const updateHint = (robot, hintEl, value) => {
          if (!hintEl) return;

          if (value === "human") {
            hintEl.style.display = "";
            hintEl.textContent = (robot.name === "Blue")
              ? "KB: IJKL/UO + Enter"
              : "KB: WASD/QE + Space";
          } else {
            hintEl.style.display = "none";
            hintEl.textContent = "";
          }
        };

        const apply = (robot, selEl, hintEl) => {
          const value = selEl.value;
          robot.setController(makeController(robot, value));
          updateHint(robot, hintEl, value);
        };

        // Defaults
        redSel.value = "human";
        blueSel.value = "human";

        // Wire events
        redSel.addEventListener("change", () => apply(this.redRobot, redSel, redHint));
        blueSel.addEventListener("change", () => apply(this.blueRobot, blueSel, blueHint));

        // Apply once at startup
        apply(this.redRobot, redSel, redHint);
        apply(this.blueRobot, blueSel, blueHint);
      }


      // -----------------------------
      // PRELOAD ROBOT FUEL
      // -----------------------------
      preloadRobotFuel() {
        // Clear any existing stored references (safe if called during reset)
        this.blueRobot.state.fuelStore = [];
        this.redRobot.state.fuelStore = [];

        for (let i = 0; i < PRELOADED_FUEL; i++) {
          const fb = new Fuel(this);
          fb.stash("Blue");
          this.fuels.push(fb);
          this.blueRobot.state.fuelStore.push(fb);

          const fr = new Fuel(this);
          fr.stash("Red");
          this.fuels.push(fr);
          this.redRobot.state.fuelStore.push(fr);
        }
      }

      // -----------------------------
      // UI / TIMER
      // -----------------------------
      getActiveElapsedMs(nowMs) {
        let pausedSoFar = this.pausedTotalMs;
        if (!this.isRunning && this.pauseStartMs != null) {
          pausedSoFar += (nowMs - this.pauseStartMs);
        }
        return (nowMs - this.matchStartMs - pausedSoFar);
      }

      setTimeUI(remainingS) {
        if (!this.timeText) return;
        const total = Math.max(0, Math.ceil(remainingS));
        const m = Math.floor(total / 60);
        const s = total % 60;
        this.timeText.setText(`${m}:${s.toString().padStart(2, "0")}`);
      }

      setTimeframeCountdownUI(remainingS) {
        if (!this.timeframeCounterText) return;
        const total = Math.max(0, Math.ceil(remainingS));
        const m = Math.floor(total / 60);
        const s = total % 60;
        this.timeframeCounterText.setText(`${m}:${s.toString().padStart(2, "0")}`);
      }

      playMatchSound(key) {
        if (!this.sound) return;
        if (this.sound.locked) {
          const onceUnlocked = () => {
            this.sound.off("unlocked", onceUnlocked);
            this.sound.play(key);
          };
          this.sound.on("unlocked", onceUnlocked);
          return;
        }
        this.sound.play(key);
      }

      toggleRun() {
        if (this.matchOver) return;

        const now = Date.now();
        if (this.isRunning) {
          this.isRunning = false;
          this.pauseStartMs = now;
          this.matter.world.pause();
          if (this.toggleBtnText) this.toggleBtnText.setText("Start");
        } else {
          this.isRunning = true;
          if (this.pauseStartMs != null) {
            this.pausedTotalMs += (now - this.pauseStartMs);
            this.pauseStartMs = null;
          }
          this.matter.world.resume();
          if (this.toggleBtnText) this.toggleBtnText.setText("Stop");
          if (!this.hasMatchStarted) {
            this.hasMatchStarted = true;
            this.playMatchSound("matchStart");
          }
        }
      }

      // -----------------------------
      // TIMEFRAMES / HUB ACTIVE LOGIC
      // -----------------------------
      getTimeframeIndex(elapsedS) {
        let t = elapsedS;
        for (let i = 0; i < TIMEFRAMES.length; i++) {
          t -= TIMEFRAMES[i].durationS;
          if (t < 0) return i;
        }
        return TIMEFRAMES.length - 1;
      }

      getTimeframeRemainingS(elapsedS) {
        let t = elapsedS;
        for (let i = 0; i < TIMEFRAMES.length; i++) {
          const durationS = TIMEFRAMES[i].durationS;
          if (t < durationS) return (durationS - t);
          t -= durationS;
        }
        return 0;
      }

      getHubActivationForTimeframe(tf) {
        if (tf === "AUTO" || tf === "TRANSITION" || tf === "ENDGAME") {
          return {red: true, blue: true};
        }

        if (tf === "SHIFT1") {
          if (this.autoLeader === "RED") return {red: true, blue: false};
          if (this.autoLeader === "BLUE") return {red: false, blue: true};
          return {red: true, blue: true};
        }

        const shiftIndex = (tf === "SHIFT2") ? 0 : (tf === "SHIFT3") ? 1 : 2;
        let redActive;
        if (this.autoLeader === "RED") {
          redActive = (shiftIndex % 2 === 1);
        } else if (this.autoLeader === "BLUE") {
          redActive = (shiftIndex % 2 === 0);
        } else {
          redActive = (shiftIndex % 2 === 0);
        }

        return {red: !!redActive, blue: !redActive};
      }

      updateHubTransitionWarning(nowMs, elapsedS) {
        const idx = this.getTimeframeIndex(elapsedS);
        const curr = TIMEFRAMES[idx]?.name;
        const next = TIMEFRAMES[idx + 1]?.name;
        const timeLeft = this.getTimeframeRemainingS(elapsedS);

        if (curr === "ENDGAME") {
          const endgameWarn = (timeLeft > 0 && timeLeft <= 3);
          this.redHub.setFlashWarning(endgameWarn, nowMs);
          this.blueHub.setFlashWarning(endgameWarn, nowMs);
          return;
        }

        if (!curr || !next || timeLeft > 3) {
          this.redHub.setFlashWarning(false, nowMs);
          this.blueHub.setFlashWarning(false, nowMs);
          return;
        }

        const currentActive = this.getHubActivationForTimeframe(curr);
        const nextActive = this.getHubActivationForTimeframe(next);

        const redWarning = currentActive.red && !nextActive.red;
        const blueWarning = currentActive.blue && !nextActive.blue;

        this.redHub.setFlashWarning(redWarning, nowMs);
        this.blueHub.setFlashWarning(blueWarning, nowMs);

        // Play a single shift cue in the final 1 second before a normal timeframe transition,
        // but skip the AUTO->TRANSITION boundary.
        if (curr !== "AUTO" && curr !== "SHIFT4" &&
          timeLeft > 0 && timeLeft <= 1 && this.lastPlayedTransitionWarningFor !== curr) {
          this.playMatchSound("matchShiftChange");
          this.lastPlayedTransitionWarningFor = curr;
        }
      }

      applyTimeframeForElapsedS(elapsedS) {
        const idx = this.getTimeframeIndex(elapsedS);
        if (idx === this.currentTimeframeIndex) return;

        const prev = this.currentTimeframeIndex;
        const prevName = (prev >= 0) ? TIMEFRAMES[prev].name : null;
        this.currentTimeframeIndex = idx;

        const tf = TIMEFRAMES[idx].name;
        if (this.timeframeText) this.timeframeText.setText(TIMEFRAME_DISPLAY_LABELS[tf] || tf);

        // Decide autoLeader when leaving AUTO
        if (prev !== -1 && TIMEFRAMES[prev].name === "AUTO" && tf !== "AUTO") {
          const r = this.redRobot.state.score;
          const b = this.blueRobot.state.score;
          if (r > b) this.autoLeader = "RED";
          else if (b > r) this.autoLeader = "BLUE";
          else this.autoLeader = (Math.random() < 0.5) ? "RED" : "BLUE";
        }

        const active = this.getHubActivationForTimeframe(tf);
        this.redHub.setActive(active.red);
        this.blueHub.setActive(active.blue);

        // Match sounds aligned to FRC-style transitions.
        if (prevName === "AUTO" && tf === "TRANSITION") {
          this.playMatchSound("matchResume");
        } else if (tf === "ENDGAME" && this.lastPlayedTimeframeName !== "ENDGAME") {
          this.playMatchSound("matchWarningSonar");
        }
        this.lastPlayedTimeframeName = tf;
      }

      // -----------------------------
      // HUB SENSOR HELPERS
      // -----------------------------
      addHexSensor(cx, cy, r, category, mask, tagName) {
        const verts = [];
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 3) * i;
          verts.push({x: Math.cos(a) * r, y: Math.sin(a) * r});
        }

        const body = this.matter.add.fromVertices(cx, cy, verts, {isStatic: true, isSensor: true}, true);

        const parts = body.parts && body.parts.length ? body.parts : [body];
        for (const p of parts) {
          p.collisionFilter.category = category;
          p.collisionFilter.mask = mask;
          p[tagName] = true;
          if (p.parent) p.parent[tagName] = true;
        }
        return body;
      }

      // -----------------------------
      // FUEL
      // -----------------------------
      spawnFuelGrid() {
        for (let r = 0; r < GRID_ROWS; r++) {
          for (let c = 0; c < GRID_COLS; c++) {
            const x = this.gridStartX + c * FUEL_SPACING_X + Phaser.Math.FloatBetween(-GRID_JITTER, GRID_JITTER);

            const midRow = Math.floor(GRID_ROWS / 2);
            const extraGapY = (r >= midRow) ? GRID_MID_GAP_PX : 0;

            const y = this.gridStartY + r * FUEL_SPACING_Y + extraGapY + Phaser.Math.FloatBetween(-GRID_JITTER, GRID_JITTER);

            const f = new Fuel(this).spawnGround(x, y);
            this.fuels.push(f);
          }
        }
      }

      spawnFuelDepot(startX, startY) {
        for (let r = 0; r < DEPOT_ROWS; r++) {
          for (let c = 0; c < DEPOT_COLS; c++) {
            const x = startX + c * FUEL_SPACING_X;
            const y = startY + r * FUEL_SPACING_Y;
            const f = new Fuel(this).spawnGround(x, y);
            this.fuels.push(f);
          }
        }
      }

      spawnFuelDepots() {
        // Red depot: along LEFT back wall, offset down from top (like the picture)
        const redStartX = DEPOT_INSET_X + FUEL_R;

        const depotW = (DEPOT_COLS - 1) * FUEL_SPACING_X;
        const depotH = (DEPOT_ROWS - 1) * FUEL_SPACING_Y;

        // Pick "centers" that match the screenshot feel
        const redCenterY = FIELD_H * 0.22; // ~ upper-left depot
        const blueCenterY = FIELD_H * 0.78; // ~ lower-right depot

        let redStartY = redCenterY - depotH / 2;
        let blueStartY = blueCenterY - depotH / 2;

        // Clamp to keep whole depot inside bounds
        const minY = DEPOT_INSET_Y + FUEL_R;
        const maxY = (FIELD_H - DEPOT_INSET_Y - FUEL_R) - depotH;

        redStartY = Phaser.Math.Clamp(redStartY, minY, maxY);
        blueStartY = Phaser.Math.Clamp(blueStartY, minY, maxY);

        // Blue depot: along RIGHT back wall
        const blueStartX = (FIELD_W - DEPOT_INSET_X - FUEL_R) - depotW;

        this.spawnFuelDepot(redStartX, redStartY);
        this.spawnFuelDepot(blueStartX, blueStartY);

        // Save depot centers for robot spawning
        this.redDepotCenter = {x: redStartX + depotW / 2, y: redStartY + depotH / 2};
        this.blueDepotCenter = {x: blueStartX + depotW / 2, y: blueStartY + depotH / 2};

      }

      getRobotStartPoseForAlliance(name) {
        const isRed = (name === "Red");
        const depot = isRed ? this.redDepotCenter : this.blueDepotCenter;
        const lineX = isRed ? RED_LINE_X : BLUE_LINE_X;

        // Halfway between the line and the depot center (x)
        const x = (lineX + depot.x) / 2;
        const y = depot.y;

        // Face the depot
        const forwardAng = Math.atan2(depot.y - y, depot.x - x);
        const angle = forwardAng - FORWARD_OFFSET; // convert forward angle to body.angle

        return {x, y, angle};
      }

      deleteFuelBody(fuelBody) {
        const idx = this.fuels.findIndex((f) => f.body === fuelBody);
        if (idx < 0) {
          this.matter.world.remove(fuelBody);
          return;
        }
        const f = this.fuels[idx];
        this.fuels.splice(idx, 1);
        f.destroy();
      }

      // Shooting uses turret direction and reuses stored Fuel objects
      tryShoot(robotObj) {
        if (this.matchOver) return;

        const now = Date.now();
        if (now - robotObj.state.lastShotTime < SHOT_PAUSE_MS) return;

        if (robotObj.state.fuelStore.length <= 0) {
          robotObj.state.lastNoAmmoMs = now;
          return;
        }

        robotObj.state.lastShotTime = now;

        const baseAng = robotObj.turretAngle;
        const ang = baseAng + Phaser.Math.FloatBetween(-SHOOT_SPREAD, SHOOT_SPREAD);

        const sx = robotObj.body.position.x + Math.cos(baseAng) * (ROBOT_W * 0.55);
        const sy = robotObj.body.position.y + Math.sin(baseAng) * (ROBOT_W * 0.55);

        // Pop one stored Fuel object (it remains in scene.fuels master list)
        const fuel = robotObj.state.fuelStore.pop();

        fuel.spawnFromShot({
          sx, sy, ang, now,
          CAT_FUEL: this.CAT_FUEL,
          CAT_FIELD_WALLS: this.CAT_FIELD_WALLS,
          CAT_SENSOR: this.CAT_SENSOR
        });
      }

      // -----------------------------
      // ZONES
      // -----------------------------
      getZoneForX(x) {
        if (x < RED_LINE_X) return this.zones[0];
        if (x < BLUE_LINE_X) return this.zones[1];
        return this.zones[2];
      }

      // -----------------------------
      // RESET
      // -----------------------------
      resetMatch() {
        // Destroy ALL fuels (world + stored)
        for (const f of this.fuels) f.destroy();
        this.fuels = [];

        this.redHub.fuelStore = [];
        this.blueHub.fuelStore = [];

        this.matchStartMs = Date.now();
        this.matchOver = false;

        // Reset to PAUSED
        this.isRunning = false;
        this.hasMatchStarted = false;
        this.pausedTotalMs = 0;
        this.pauseStartMs = Date.now();
        this.matter.world.pause();
        if (this.toggleBtnText) this.toggleBtnText.setText("Start");

        this.lastPlayedTimeframeName = null;
        this.lastPlayedTransitionWarningFor = null;
        this.hasPlayedMatchEndSound = false;

        // Reset timeframe state
        this.currentTimeframeIndex = -1;
        this.autoLeader = "TIE";
        this.redHub.setActive(true);
        this.blueHub.setActive(true);

        // Respawn field fuel
        this.spawnFuelGrid();
        this.spawnFuelDepots();


        // Reset robot states
        this.blueRobot.state = new this.RobotState();
        this.redRobot.state = new this.RobotState();

        // Reset poses
        this.blueRobot.setPose(this.getRobotStartPoseForAlliance("Blue"));
        this.redRobot.setPose(this.getRobotStartPoseForAlliance("Red"));

        // Preload fuel again as real objects in master list (stashed)
        this.preloadRobotFuel();

        // Reset timer UI
        this.setTimeUI(MATCH_TIME_S);
        this.applyTimeframeForElapsedS(0);
        this.setTimeframeCountdownUI(this.getTimeframeRemainingS(0));
      }

      update(time, delta) {
        // Reset
        if (Phaser.Input.Keyboard.JustDown(this.keys?.reset)) {
          this.resetMatch();
        }

        // Timer based on active time
        const now = Date.now();
        const activeElapsedS = this.getActiveElapsedMs(now) / 1000.0;
        const remaining = Math.max(0, MATCH_TIME_S - activeElapsedS);

        // Eject fuel from hubs
        this.redHub.update(now);
        this.blueHub.update(now);

        // Apply timeframe transitions
        this.applyTimeframeForElapsedS(activeElapsedS);
        this.setTimeframeCountdownUI(this.getTimeframeRemainingS(activeElapsedS));
        this.updateHubTransitionWarning(now, activeElapsedS);

        // Match end behavior
        if (remaining <= 0 && !this.matchOver) {
          this.matchOver = true;
          this.isRunning = false;
          this.matter.world.pause();
          if (this.toggleBtnText) this.toggleBtnText.setText("Start");
          if (!this.hasPlayedMatchEndSound) {
            this.hasPlayedMatchEndSound = true;
            this.playMatchSound("matchEnd");
          }
        }

        this.setTimeUI(remaining);

        // If stopped, do not advance physics-driven updates
        if (!this.isRunning) {
          const zoneCounts = this.computeZoneCountsIncludeStored();
          if (this.zoneCountText) {
            this.zoneCountText[ZoneId.RED].setText(`${zoneCounts[ZoneId.RED]}`);
            this.zoneCountText[ZoneId.NEUTRAL].setText(`${zoneCounts[ZoneId.NEUTRAL]}`);
            this.zoneCountText[ZoneId.BLUE].setText(`${zoneCounts[ZoneId.BLUE]}`);
          }

          if (this.redScoreText) this.redScoreText.setText(`${this.redRobot.state.score}`);
          if (this.blueScoreText) this.blueScoreText.setText(`${this.blueRobot.state.score}`);
          return;
        }

        // Update robots
        this.blueRobot.update(delta);
        this.redRobot.update(delta);

        // Airborne visuals + landing behavior (stored fuel no-ops)
        for (const f of this.fuels) f.update(now);

        // Zone fuel counts
        const zoneCounts = this.computeZoneCountsIncludeStored();
        if (this.zoneCountText) {
          this.zoneCountText[ZoneId.RED].setText(`${zoneCounts[ZoneId.RED]}`);
          this.zoneCountText[ZoneId.NEUTRAL].setText(`${zoneCounts[ZoneId.NEUTRAL]}`);
          this.zoneCountText[ZoneId.BLUE].setText(`${zoneCounts[ZoneId.BLUE]}`);
        }

        // Score UI
        if (this.redScoreText) this.redScoreText.setText(`${this.redRobot.state.score}`);
        if (this.blueScoreText) this.blueScoreText.setText(`${this.blueRobot.state.score}`);

        // Debug HUD
        // Debug HUD (World vs Stored + invariant check)
        const sleeping = this.fuels.reduce((acc, f) => acc + (f.body && f.body.isSleeping ? 1 : 0), 0);

        const storedBlue = this.blueRobot.state.fuelStore.length;
        const storedRed = this.redRobot.state.fuelStore.length;
        const storedHubBlue = this.blueHub.fuelStore.length;
        const storedHubRed = this.redHub.fuelStore.length;

        const worldCount = this.fuels.reduce((acc, f) => acc + (f.body ? 1 : 0), 0);

        const expectedTotal = worldCount + storedBlue + storedRed + storedHubBlue + storedHubRed;
        const mismatch = this.fuels.length - expectedTotal;
        const invText = (mismatch === 0) ? "OK" : `MISMATCH(Δ=${mismatch})`;

        /*
        this.HUDtext.setText(
          `FuelTotal:${this.fuels.length}  World:${worldCount}  ` +
          `Stored(B:${storedBlue} R:${storedRed}) Hub(B:${storedHubBlue} R:${storedHubRed}) (sleep:${sleeping})  Inv:${invText}\n` +
          `RED: WASD/QE + Space   BLUE: IJKL/UO + Enter   Reset: R`
        );
        */
      } // end of update()


      // -----------------------------
      // Compute number of fuel in each zone (includes robots & hubs)
      // -----------------------------
      computeZoneCountsIncludeStored() {
        const zoneCounts = {[ZoneId.RED]: 0, [ZoneId.NEUTRAL]: 0, [ZoneId.BLUE]: 0};

        // World fuel (ground + airborne): count by current x position
        for (const f of this.fuels) {
          if (!f.body) continue; // stored fuel has no body
          zoneCounts[this.getZoneForX(f.body.position.x).id]++;
        }

        // Stored fuel: count in the zone where the owning robot currently is
        const blueZone = this.getZoneForX(this.blueRobot.body.position.x).id;
        zoneCounts[blueZone] += this.blueRobot.state.fuelStore.length;

        const redZone = this.getZoneForX(this.redRobot.body.position.x).id;
        zoneCounts[redZone] += this.redRobot.state.fuelStore.length;

        return zoneCounts;
      }

      getInputForRobot(robot) {
        return robot.controls; // keyboard for now; later return merged keyboard+gamepad
      }

      getGamepadForRobot(robot) {
        const idx = robot.gamepadIndex;
        if (idx == null) return null;
        return this.input.gamepad.getPad(idx) || null;
      }

      // Helper: get hub center for alliance
      getAllianceHubPoint(alliance /* "Blue" | "Red" */) {
        const hub = (alliance === "Blue") ? this.blueHub : this.redHub;
        // you used scene.blueHub.center earlier, so keep that convention
        return {x: hub.center.x, y: hub.center.y};
      }

      // Helper: get depot center for alliance
      getAllianceDepotPoint(alliance /* "Blue" | "Red" */) {
        if (this.blueDepotCenter && alliance === "Blue") return {...this.blueDepotCenter};
        if (this.redDepotCenter && alliance === "Red") return {...this.redDepotCenter};

        // Last-resort fallback (won’t be correct for your field, but prevents crashes)
        return {x: FIELD_W * 0.5, y: FIELD_H * 0.5};
      }

    }  // end of MainScene



    new Phaser.Game({
      type: Phaser.AUTO,
      parent: "gameContainer",
      width: FIELD_W,
      height: GAME_H,
      backgroundColor: "#1b1b1b",
      input: {
        keyboard: true,
        gamepad: true   // ✅ enable gamepad support
      },
      physics: {default: "matter", matter: {gravity: {y: 0}, debug: false}},
      scene: [MainScene],
    });
  </script>
</body>

</html>
